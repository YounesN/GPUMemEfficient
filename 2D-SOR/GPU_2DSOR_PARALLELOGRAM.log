Completed:
1. skelenton code is completed.
2. stream scheduling, kernel launching, and lock functions are working properly.
3.

################################################################
May 15 2019
################################################################
Solved:
1. if (curBatch == 0): moveMatrixToTile() function is now working properly when copying a tile of size 4*4 to shared memory.
2. if (curBatch == 0): moveIntraDepToTileEdge() function works properly when tt = 0 and tileT = 1.
3. if (curBatch == 0): moveInterDepToTileEdge() function works properly when tt = 0 and tileT = 1.


Problem:
1. register resources exceed the capacity when threadsPerBlock = 1024.
2. SOR.cpp: incorrect readInputData() function. Cannot skip the first row of data. Either fix it or change paddsize to 1.


###############################################################
Jun 5th
###############################################################
Solved:
1. SOR.cpp: readInputData() function. Read all data and process only the central block of (n1+2) * (n2+2).


###############################################################
Jun 10th
##############################################################
Problem:
1. moveTileToInterDepEdge() function does not access correct memory address. The print out message is not right.
Solved;


##############################################################
Jun 11th
#############################################################
Problem:
1. moveTileToInterDep() function: inter_stream_dep[] is not stored correctly, the print information is not correct.
Found not solved.

##############################################################
Jun 17th
#############################################################
Problem:
1. in function moveMatrixToTile(), the element for the last row of the tile are not stored correctly into the shared memory.
Data entries could be accessed correctly; however, some data entries cannot be properly stored into the shared memory.
This problem is caused by swaping the data entries between shared memory tile1 and tile2.
Solved: Introducing threadfence() before the swap function.


###########################################################
Jun 18th
###########################################################
Solved:
1. "width" and "height" variables are revised. 
2. curBatch == 0, tileIdx >= 1 && tileIdx < xseg - 1; "newtilePos" is changed to store the results into the tile area instead of dependent data area.
3. curBatch == 0, tileIdx >= 1 && tileIdx < xseg - 1; "glbPos" is changed from "glbPos = tileAddress" to "glbPos = tileAddress - tileT" to adapt the shift along x dimension.
4. In function moveShareToGLobal() and moveShareToGlobalEdge(), we should use "width" instead of "height" as parameter.

Needs to be fixed:
1. Like what we did to "glbPos" in this work, we might need to change "glbPos" accordingly in other simulation to adapt the shift of data entries.


##########################################################
July 12
##########################################################
idea:
1. replace cudaMalloc with cudaManagedMalloc() to see if it allows a large size test case.

##########################################################
July 28th
##########################################################
Problem:
1. moveIntraDepToShare() may encounter error. The intra-dep data should be copied to the array for next tile before updating the next time step results of the current tile.
	a. Move intra-dep array data to shared memory block;
	b. Calculate the next time stamp result of the shared memory block;
	c. Move intra-dep data for next tile to intra-dep array.
	d. Move shared memory block back to GPU memory array.
Solved: Instead of copy data entries from global memory to intra_dep array, in shared memory, we copy the intra_dep data that locates in shared memory block, which are not updated by next stamp result, to intra_dep array.

Completed:
1. first batch with tileT == 1 is completed. Test case 3 * 3 matrix with size 2 padding.


























































